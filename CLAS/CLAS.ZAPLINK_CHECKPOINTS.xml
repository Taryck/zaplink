<?xml version="1.0" encoding="utf-16"?>
<ZL_OBJECT CHECKSUM="46B4C6CE76563343102FFB702F6DE6A1" CODE_SIGNATURE="C08042A14C3BAE4F14830DEB14DBFADD" CONNECTOR="39AC0A4B07A5A05AE1000000AC120173" NAME="ZAPLINK_CHECKPOINTS" TYPE="CLAS" VERSION="1.01">
 <DEPENDENCIES>
  <ITEM TYPE="CLAS" NAME="ZAPLINK_CONNECTOR_"/>
 </DEPENDENCIES>
 <DIRECTORY DEVCLASS="ZAPLINK-CONNECTORS-MAIN" MASTERLANG="E"/>
 <RAW>
  <A0_MAINDATA VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" CLSCCINCL="X" FIXPT="X" UNICODE="X" MSG_ID="ZAPLINK_CHECKPOINTS">
   <INHERITANCE REFCLSNAME="ZAPLINK_CONNECTOR_" STATE="1"/>
   <TEXTS>
    <ITEM LANG="E" TEXT="Connector for Check points">U1&amp;FUNCTIONALITY&amp;
ASIs a connector for :
AS- FUGR : Function Group
U1&amp;RELATIONS&amp;
ASIs part of ZAP Link Framework as Official Connector.
ASRequire Official connector for Program types (PROG).
U1&amp;EXAMPLE&amp;
AS
U1&amp;HINTS&amp;
AS
U1&amp;FURTHER_SOURCES_OF_INF&amp;
AShttps://code.google.com/p/zaplink/wiki/Connector
U1Memories
ASThis application is dedicated to the memories of :
B2My father : Lamri BENSIALI (1940-2004) without whom I never started
  programming
B2My uncle : Jacky BEDU (1934-2009) who died during the completion of this
  application</ITEM>
   </TEXTS>
  </A0_MAINDATA>
  <ATTRIBUTS>
   <ITEM CMPNAME="BALLOG_SUBOBJECT" EXPOSURE="2" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;CNX_CHECKPOINTS&apos;" TYPTYPE="1" TYPE="BALSUBOBJ">
    <TEXTS>
     <ITEM LANG="E" TEXT="Application Log: Subobject"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="SUPPORTEDKINDS" EXPOSURE="1" STATE="1" ATTDECLTYP="1" TYPTYPE="4">BEGIN OF supportedkinds,
      checkpoint        TYPE td_transport_kind,
      variant           TYPE td_transport_kind,
    END OF supportedkinds
`</ITEM>
   <ITEM CMPNAME="SUPPORTEDTYPES" EXPOSURE="1" STATE="1" ATTDECLTYP="2" TYPTYPE="4">
    BEGIN OF supportedtypes,
      checkpoint        TYPE td_comptype VALUE &apos;ACID&apos;,      &quot;#EC NOTEXT
      variant           TYPE td_comptype VALUE &apos;AVAR&apos;,      &quot;#EC NOTEXT
    END OF supportedtypes
`
    <TEXTS>
     <ITEM LANG="E" TEXT="Connector supported types"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="_UUID" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;D8638E4C3E11CC5AE1000000AC120173&apos;" TYPTYPE="1" TYPE="TD_CONNUUID">
    <TEXTS>
     <ITEM LANG="E" TEXT="UUID for connector Program"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="_VER" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;1.0&apos;" TYPTYPE="1" TYPE="TD_CONNVER">
    <TEXTS>
     <ITEM LANG="E" TEXT="Connector Version"/>
    </TEXTS>
   </ITEM>
  </ATTRIBUTS>
  <LOCAL>
   <TYPES>`
*&quot;* USE THIS SOURCE FILE FOR ANY TYPE DECLARATIONS (CLASS
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</TYPES>
   <IMPLEMENTATIONS>`
*&quot;* LOCAL CLASS IMPLEMENTATION FOR PUBLIC CLASS
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</IMPLEMENTATIONS>
   <MACROS>`
*&quot;* USE THIS SOURCE FILE FOR ANY MACRO DEFINITIONS YOU NEED
*&quot;* in the implementation part of the class

INCLUDE zaplink_macros.</MACROS>
  </LOCAL>
  <METHODS>
   <ITEM CMPNAME="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" MTDTYPE="2" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="CLASS_CONSTRUCTOR"/>
    </TEXTS>
    <SOURCE>`
  supportedkinds-checkpoint =  zaplink_connectors=&gt;get_typekind( supportedtypes-checkpoint ).
  supportedkinds-variant =  zaplink_connectors=&gt;get_typekind( supportedtypes-variant ).</SOURCE>
   </ITEM>
   <ITEM CMPNAME="CONSTRUCTOR" EXPOSURE="2" STATE="1" MTDTYPE="2">
    <TEXTS>
     <ITEM LANG="E" TEXT="CONSTRUCTOR"/>
    </TEXTS>
    <SOURCE>`
  DATA type LIKE LINE OF supported_types.

  CALL METHOD super-&gt;constructor.
  mac_create_log application_log ballog_subobject space.
  type-type = supportedtypes-checkpoint.    INSERT type INTO TABLE supported_types.
  type-type = supportedtypes-variant.       INSERT type INTO TABLE supported_types.

  uuid = _uuid.
  version = _ver.</SOURCE>
   </ITEM>
  </METHODS>
  <REDEFINITIONS>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CNX_EXT_CLEANER~ANONYMIZE">
    <SOURCE>`
  DATA o_checkpoint    TYPE to_checkpoint.
*  DATA o_variant       TYPE to_variant.

  CHECK object IS BOUND.

  CASE object-&gt;type.
    WHEN supportedtypes-checkpoint.
      o_checkpoint ?= object-&gt;raw.
      o_checkpoint-&gt;anonymize( ).
*    WHEN supportedtypes-variant.
*      o_variant ?= object-&gt;raw.
*      o_variant-&gt;anonymize( ).
    WHEN OTHERS.
       mac_raise_type_not_supported me-&gt;class_name object-&gt;type.
  ENDCASE.

  TRY.
      super-&gt;zaplink_cnx_ext_cleaner~anonymize( object ).
    CATCH zaplink_cx_connector INTO o_mycx.
      RAISE EXCEPTION o_mycx.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CNX_EXT_CLEANER~UNANONYMIZE">
    <SOURCE>`
  DATA o_checkpoint    TYPE to_checkpoint.
*  DATA o_variant       TYPE to_variant.

  CHECK object IS BOUND.

  CASE object-&gt;type.
    WHEN supportedtypes-checkpoint.
      o_checkpoint ?= object-&gt;raw.
      o_checkpoint-&gt;unanonymize( ).
*    WHEN supportedtypes-variant.
*      o_variant ?= object-&gt;raw.
*      o_variant-&gt;unanonymize( ).
    WHEN OTHERS.
       mac_raise_type_not_supported me-&gt;class_name object-&gt;type.
  ENDCASE.

  TRY.
      super-&gt;zaplink_cnx_ext_cleaner~unanonymize( object ).
    CATCH zaplink_cx_connector INTO o_mycx.
      RAISE EXCEPTION o_mycx.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CNX_EXT_CODE_SIGNATURE~GET_SIGNATURE">
    <SOURCE>`
*  DATA d_group TYPE td_functiongroup_name.
*  DATA d_func  TYPE td_function_name.
*  DATA d_type  TYPE td_comptype.
*
*  TRY.
*    d_type = component-&gt;get_type( ).
*    CASE d_type.
*      WHEN supportedtypes-checkpoint.
*        d_group = component-&gt;get_name( ).
*        result = get_group_signature( d_group ).
*      WHEN supportedtypes-variant.
*        d_func = component-&gt;get_name( ).
*        result = get_function_signature( d_func ).
*      WHEN OTHERS.
*        mac_raise_type_not_supported me-&gt;class_name d_type.
*    ENDCASE.
*
*    mac_def_catch zaplink_cx_connector.
*  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~CREATE_NEW_RAW">
    <SOURCE>`
  DATA o_checkpoint   TYPE to_checkpoint.
  DATA o_variant      TYPE to_variant.

  CASE type.
    WHEN supportedtypes-checkpoint.
      CREATE OBJECT object.
      CREATE OBJECT o_checkpoint.
      object-&gt;raw = o_checkpoint.
    WHEN supportedtypes-variant.
      CREATE OBJECT object.
      CREATE OBJECT o_variant.
      object-&gt;raw = o_variant.
    WHEN OTHERS.
      CLEAR object.
      mac_raise_type_not_supported me-&gt;class_name type.
  ENDCASE.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~DELETE_FROM_SAP">
    <SOURCE>`
  DATA o_checkpoint   TYPE REF TO cl_aab_id.
  DATA d_checkpoint   TYPE td_checkpoint.
  DATA state          TYPE flag.
  DATA o_variant      TYPE REF TO cl_aab_variant.
*  DATA d_variant      TYPE td_checkpoint.
  DATA type           TYPE td_comptype.
  DATA name           TYPE td_compname.

  TRY.
    type = component-&gt;get_type( ).
    CASE type.
      WHEN supportedtypes-checkpoint.
        d_checkpoint = name = component-&gt;get_name( ).

        CREATE OBJECT o_checkpoint
          EXPORTING
            im_name          = d_checkpoint
          EXCEPTIONS
            name_not_allowed = 1
            OTHERS           = 2.
        IF sy-subrc &lt;&gt; 0.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING textid = zaplink_cx_connector=&gt;not_found
                        type = type
                        name = name.
        ENDIF.

        CALL METHOD o_checkpoint-&gt;enqueue
*          EXPORTING
*            enqueue_mode = &apos;E&apos;
*            no_cts       = SPACE
           EXCEPTIONS
             cts_error    = 1
             foreign_lock = 2
             system_error = 3
             OTHERS       = 4.
        IF sy-subrc &lt;&gt; 0.
          mac_add_obj_meth_and_raise o_checkpoint &apos;ENQUEUE&apos; sy-subrc.
        ENDIF.

        CALL METHOD o_checkpoint-&gt;delete
          EXCEPTIONS
            act_error        = 1
            cts_devclass     = 2
            cts_error        = 3
            id_not_found     = 4
            id_still_used    = 5
            no_authorization = 6
            propt_error      = 7
            prop_error       = 8
            where_used_error = 9
            OTHERS           = 10.
        IF sy-subrc &lt;&gt; 0.
          mac_add_obj_meth_and_raise o_checkpoint &apos;DELETE&apos; sy-subrc.
        ENDIF.

*        o_checkpoint-&gt;dequeue =&gt; Made on commit

      WHEN supportedtypes-variant.
*        d_function = component-&gt;get_name( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me-&gt;class_name type.
    ENDCASE.

    mac_def_catch zaplink_cx_connector.
  ENDTRY.

  result = abap_true.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~DO_EXISTS">
    <SOURCE>`
  DATA o_checkpoint   TYPE REF TO cl_aab_id.
  DATA d_checkpoint   TYPE td_checkpoint.
  DATA state          TYPE flag.
  DATA o_variant      TYPE REF TO cl_aab_variant.
*  DATA d_variant      TYPE td_checkpoint.
  DATA type           TYPE td_comptype.

  exists = me-&gt;exists-not_exists.

  TRY.
    type = component-&gt;get_type( ).
    CASE type.
      WHEN supportedtypes-checkpoint.
        d_checkpoint = component-&gt;get_name( ).
        CREATE OBJECT o_checkpoint
          EXPORTING
            im_name          = d_checkpoint
          EXCEPTIONS
            name_not_allowed = 1
            OTHERS           = 2.
        IF sy-subrc = 0.
          o_checkpoint-&gt;get_state( IMPORTING ex_state = state ).
          IF NOT state IS INITIAL.     exists = me-&gt;exists-exists.     ENDIF.
        ENDIF.

      WHEN supportedtypes-variant.
*        d_function = component-&gt;get_name( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me-&gt;class_name type.
    ENDCASE.

    mac_def_catch zaplink_cx_connector.
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~IS_SUPPORTED_VERSION">
    <SOURCE>`
  result = abap_false.
  if version = _ver.
    result = abap_true.
  endif.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~READ_FROM_SAP">
    <SOURCE>`
  DATA o_aab_id         TYPE REF TO cl_aab_id.
  DATA o_checkpoint     TYPE to_checkpoint.
  DATA s_fmd_acid       TYPE ts_fmd_acid.
*  DATA d_checkpoint     TYPE td_checkpoint.
  DATA type             TYPE td_comptype.
  DATA name             TYPE td_compname.
  DATA l_mode           TYPE aab_id_mode.
  DATA l_tstamp         TYPE aab_id_act-act_tstamp.

  TRY.
    type = component-&gt;get_type( ).
    CREATE OBJECT object.
    object-&gt;set_component( component ).
    CASE type.
      WHEN supportedtypes-checkpoint.
        s_fmd_acid-header-name = name = component-&gt;get_name( ).
        CREATE OBJECT o_aab_id
          EXPORTING
            im_name          = s_fmd_acid-header-name
          EXCEPTIONS
            name_not_allowed = 1
            OTHERS           = 2.
        IF sy-subrc &lt;&gt; 0.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING textid = zaplink_cx_connector=&gt;not_found
                        type = type
                        name = name.
        ENDIF.

*        CALL METHOD o_aab_id-&gt;get_descript
*          EXPORTING
*            im_enforce_db_read   = abap_true
**            im_set_attribute     = &apos;X&apos;
*          IMPORTING
*            ex_descript          = s_fmd_acid-header-descript
*          EXCEPTIONS
*            no_description_found = 1
*            OTHERS               = 2.
*        IF sy-subrc &lt;&gt; 0.
*        ENDIF.
* Multilang =&gt;
        SELECT * INTO TABLE s_fmd_acid-descriptions
          FROM aab_id_propt
          WHERE name = s_fmd_acid-header-name.

* From LSAABP01 : Methode pbo_0310.
        CALL METHOD o_aab_id-&gt;get_all_modes
          IMPORTING
            ex_modes_tab  = s_fmd_acid-modes
          EXCEPTIONS
            no_mode_found = 1
            system_error  = 2
            others        = 3.
        IF sy-subrc &lt;&gt; 0.
          mac_add_obj_meth_and_raise o_aab_id &apos;GET_ALL_MODES&apos; sy-subrc.
        ENDIF.

        CREATE OBJECT o_checkpoint.
        o_checkpoint-&gt;from_data( s_fmd_acid ).
        CLEAR s_fmd_acid-header-name.
        object-&gt;raw = o_checkpoint.

      WHEN supportedtypes-variant.
*        d_function = component-&gt;get_name( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me-&gt;class_name type.
    ENDCASE.

    mac_def_catch zaplink_cx_connector.
  ENDTRY.

*    CASE type.
*      WHEN supportedtypes-variant.
*        s_fmd_func-header-name = object-&gt;name.
*        s_fmd_func = read_function( s_fmd_func-header-name ).
*        s_fmd_func-code_signature = calc_function_signature( s_fmd_func ).
*        CREATE OBJECT o_variant.
*        o_variant-&gt;from_data( s_fmd_func ).
*        CLEAR o_variant-&gt;a0_maindata-name.
*        object-&gt;raw = o_variant.
*      WHEN supportedtypes-checkpoint.
*        s_fmd_acid-header-area = d_name = object-&gt;name.
*        CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
*          EXPORTING
*            function_pool           = s_fmd_acid-header-area
*          TABLES
*            functab                 = t_functions
*          EXCEPTIONS
*            function_pool_not_found = 1
*            OTHERS                  = 2.
*        IF sy-subrc &lt;&gt; 0.
*          mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; sy-subrc.
*        ENDIF.
*
*        d_doc = d_mainprog = get_mainprogram( s_fmd_acid-header-area ).
*        s_fmd_acid-docs = zaplink_documentation=&gt;get( ids = zaplink_acid_data=&gt;r_doc_ids-group
*                                                  object = d_doc  ).
*
*        SELECT * INTO TABLE s_fmd_acid-texts FROM tlibt WHERE area = s_fmd_acid-header-area.
** Issue 95
**        SELECT * INTO TABLE s_fmd_acid-function_texts FROM tftit FOR ALL ENTRIES IN t_functions WHERE funcname = t_functions-funcname.
**        SELECT * INTO TABLE s_fmd_acid-param_texts FROM funct FOR ALL ENTRIES IN t_functions WHERE funcname = t_functions-funcname.
*        LOOP AT t_functions ASSIGNING &lt;f&gt;.
*          s_fmd_func = read_function( &lt;f&gt;-funcname ).   clear s_fmd_func-header-str_area.
*          s_fmd_func-code_signature = calc_function_signature( s_fmd_func ).
*          INSERT s_fmd_func INTO TABLE s_fmd_acid-functions.
*        ENDLOOP.
*
*        SELECT SINGLE dlvunit INTO d_soft_comp
*          FROM v_tralan
*          WHERE pgmid = supportedkinds-group
*            AND object = supportedtypes-checkpoint
*            AND obj_name = s_fmd_acid-header-area.
*
*        s_fmd_acid-includes = get_all_includes( s_fmd_acid-header-area ).
*
**          s_fmd_acid-includes = remove_unwanted_includes( includes = s_fmd_acid-includes
**                                                        functions = t_functions
**                                                        soft_comp = d_soft_comp ).
*
** Texts Pool
*        s_fmd_acid-textspool = get_prog_textpool( d_mainprog ).
*
** Dynpro
*        s_fmd_acid-dynpros = get_dynpros( d_mainprog ).
*
** Menu Painter
*        s_fmd_acid-menupainter = get_menus( d_mainprog ).
*** Documentation
***      CONCATENATE _name &apos;*&apos; INTO _obj. &quot; Issue:7
**          s_obj-prog = _name.
**          s_obj-wildcard = &apos;*&apos;.
**          _obj = s_obj.
***Issue:7
**          o_checkpoint-&gt;documentation = zaplink_documentation=&gt;get( ids = r_doc_id
**                                                          object = _obj ).
*        CREATE OBJECT o_checkpoint.
*        o_checkpoint-&gt;from_data( s_fmd_acid ).
*        o_checkpoint-&gt;_code_signature = get_group_signature( o_checkpoint-&gt;a0_maindata-area ).
*        CLEAR o_checkpoint-&gt;a0_maindata-area.
*        object-&gt;raw = o_checkpoint.
*      WHEN OTHERS.
*        CLEAR object.
*        mac_raise_type_not_supported me-&gt;class_name type.
*    ENDCASE.
*    object-&gt;update_connector_data( me ).                    &quot; Issue 66
*    mac_def_catch zaplink_cx_connector.
*  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM REFCLSNAME="ZAPLINK_CONNECTOR_" MTDNAME="ZAPLINK_CONNECTOR~WRITE_TO_SAP">
    <SOURCE>`
  DATA o_aab_id         TYPE REF TO cl_aab_id.
  DATA o_checkpoint     TYPE to_checkpoint.
  DATA s_fmd_acid       TYPE ts_fmd_acid.
*  DATA o_variant   TYPE to_variant.
*  DATA s_fmd_func  TYPE ts_fmd_func.
  DATA _comp        TYPE to_component.
  DATA s_desc       LIKE LINE OF s_fmd_acid-descriptions.
  DATA d_nb_err     TYPE i.
  DATA lt_modes     TYPE aab_id_act_tab.
  FIELD-SYMBOLS:
    &lt;o&gt;  LIKE LINE OF lt_modes,
    &lt;m&gt;  LIKE LINE OF s_fmd_acid-modes.

  TRY.
      CREATE OBJECT components.
      CASE object-&gt;type.
        WHEN supportedtypes-variant.
*          o_variant ?= object-&gt;raw.
*          o_variant-&gt;a0_maindata-name = object-&gt;name.
*          s_fmd_func = o_variant-&gt;to_data( ).
*
*          del_function( s_fmd_func ).
*          write_function( s_fmd_func ).
*          CALL FUNCTION &apos;RS_FUNCTION_POOL_CONTENTS&apos;
*            EXPORTING
*              function_pool           = s_fmd_func-header-str_area
*            TABLES
*              functab                 = t_functions
*            EXCEPTIONS
*              function_pool_not_found = 1
*              OTHERS                  = 2.
*          IF sy-subrc &lt;&gt; 0.
*            ROLLBACK WORK.
          mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; sy-subrc.
*          ENDIF.
*          READ TABLE t_functions ASSIGNING &lt;fi&gt; WITH KEY funcname = s_fmd_func-header-name.
*          IF sy-subrc &lt;&gt; 0. mac_add_mf_and_raise &apos;RS_FUNCTION_POOL_CONTENTS&apos; 2. ENDIF.
**          set_prog_rawsource( program = &lt;fi&gt;-include
**                                  raw = s_fmd_func-source ).
*
        WHEN supportedtypes-checkpoint.
          o_checkpoint ?= object-&gt;raw.
          o_checkpoint-&gt;a0_maindata-name = object-&gt;name.
          s_fmd_acid = o_checkpoint-&gt;to_data( ).
          s_fmd_acid-header-name = object-&gt;name.
          CREATE OBJECT o_aab_id
            EXPORTING
              im_name          = s_fmd_acid-header-name
            EXCEPTIONS
              name_not_allowed = 1
              OTHERS           = 2.
          IF sy-subrc &lt;&gt; 0.
            mac_add_name_meth_and_raise &apos;cl_aab_id&apos; &apos;CONSTRUCTOR&apos; sy-subrc &apos;ZAPLINK_CX_CONNECTOR&apos;.
          ENDIF.

          CALL METHOD o_aab_id-&gt;enqueue
            EXPORTING
              enqueue_mode = &apos;E&apos;
              no_cts       = space
            EXCEPTIONS
              cts_error    = 1
              foreign_lock = 2
              system_error = 3
              OTHERS       = 4.
          IF sy-subrc &lt;&gt; 0.
            mac_add_obj_meth_and_raise o_aab_id &apos;ENQUEUE&apos; sy-subrc.
          ENDIF.

          CALL METHOD o_aab_id-&gt;get_all_modes
            IMPORTING
              ex_modes_tab  = lt_modes
            EXCEPTIONS
              no_mode_found = 1.
          IF sy-subrc = 0.
            LOOP AT lt_modes ASSIGNING &lt;o&gt;.
              READ TABLE s_fmd_acid-modes TRANSPORTING NO FIELDS WITH KEY
*              name = &lt;o&gt;-name
                username = &lt;o&gt;-username
                server = &lt;o&gt;-server
                is_program = &lt;o&gt;-is_program
                actdefault = &lt;o&gt;-actdefault.
              CHECK sy-subrc &lt;&gt; 0.
              CALL METHOD o_aab_id-&gt;delete_mode
                EXPORTING
                  im_user           = &lt;o&gt;-username
                  im_server         = &lt;o&gt;-server
                  im_actdefault     = &lt;o&gt;-actdefault
                  im_delete_from_db = space
                EXCEPTIONS
                  no_mode_found     = 0
                  no_authorization  = 2
                  act_error         = 1
                  OTHERS            = 4.
              IF sy-subrc &lt;&gt; 0.
                mac_add_obj_meth_and_raise o_aab_id &apos;DELETE_MODE&apos; sy-subrc.
              ENDIF.
            ENDLOOP.
          ENDIF.

          LOOP AT s_fmd_acid-modes ASSIGNING &lt;m&gt;.
            CALL METHOD o_aab_id-&gt;set_mode
              EXPORTING
                im_user            = &lt;m&gt;-username
                im_server          = &lt;m&gt;-server
                im_actdefault      = &lt;m&gt;-actdefault
                im_mode            = &lt;m&gt;-actmode
*                im_act_tstamp      =
*                im_exp_tstamp      =
*                im_no_autho_check  = SPACE
               IMPORTING
                 ex_nr_of_conflicts = d_nb_err
               EXCEPTIONS
                 no_authorization   = 1
                 OTHERS             = 2.
            IF sy-subrc &lt;&gt; 0.
              mac_add_obj_meth_and_raise o_aab_id &apos;SET_MODE&apos; sy-subrc.
            ELSEIF d_nb_err &lt;&gt; 0.

            ENDIF.
          ENDLOOP.

          CALL METHOD o_aab_id-&gt;save
*            EXPORTING
*              no_change_rtm_activation = SPACE
            EXCEPTIONS
              act_error                = 1
              cts_error                = 2
              no_changes_found         = 3
              no_descript_specified    = 4
              prop_error               = 5
              propt_error              = 6
              sync_attributes_error    = 7
              OTHERS                   = 8.
          IF sy-subrc &lt;&gt; 0.
            mac_add_obj_meth_and_raise o_aab_id &apos;SAVE&apos; sy-subrc.
          ENDIF.

*          CALL METHOD o_aab_id-&gt;set_descript
*            EXPORTING
*              im_descript      =
**            EXCEPTIONS
**              no_authorization = 1
**              others           = 2
*                  .
* Multilang =&gt;
          DELETE FROM aab_id_propt WHERE name = s_fmd_acid-header-name.
          s_desc-name = s_fmd_acid-header-name.   MODIFY s_fmd_acid-descriptions FROM s_desc TRANSPORTING name WHERE name &lt;&gt; s_fmd_acid-header-name.
          INSERT aab_id_propt FROM TABLE s_fmd_acid-descriptions.

          CALL METHOD o_aab_id-&gt;dequeue
            EXPORTING
              dequeue_mode = &apos;E&apos;.

        WHEN OTHERS.
          mac_raise_type_not_supported me-&gt;class_name object-&gt;type.
      ENDCASE.
      _comp = object-&gt;get_component( abap_true ).
      TRY.
          components-&gt;add( _comp ).
          CATCH zaplink_cx_list.  ENDTRY.                   &quot; Issue 92

        CATCH zaplink_cx_connector INTO o_mycx.
          ROLLBACK WORK.
          RAISE EXCEPTION o_mycx.
        CATCH zaplink_cx INTO o_cx.
          ROLLBACK WORK.
          mac_cascade_raise o_mycx o_cx.
      ENDTRY.</SOURCE>
   </ITEM>
  </REDEFINITIONS>
  <TEXTSPOOL>
   <ITEM ID="I" KEY="D00">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Confirm module function deletion" LENGTH="50 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="HNO">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Function is not deleted and process to next existing function. Function group will be created without this function." LENGTH="132 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="HYE">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Function is deleted. Function group will be created with this function." LENGTH="132 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="NO_">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="No" LENGTH="15 "/>
    </TEXTS>
   </ITEM>
   <ITEM ID="I" KEY="YES">
    <TEXTS>
     <ITEM LANGU="E" ENTRY="Yes" LENGTH="15 "/>
    </TEXTS>
   </ITEM>
  </TEXTSPOOL>
  <TYPEGROUPS>
   <ITEM TYPEGROUP="ABAP" EXPLICIT="X"/>
  </TYPEGROUPS>
  <TYPES>
   <ITEM CMPNAME="TD_CHECKPOINT" EXPOSURE="1" STATE="1" TYPTYPE="1" TYPE="AAB_ID_NAME">
    <TEXTS>
     <ITEM LANG="E" TEXT="Checkpoint Group"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TD_VARIANT" EXPOSURE="1" STATE="1" TYPTYPE="1" TYPE="STRING"/>
   <ITEM CMPNAME="TO_CHECKPOINT" EXPOSURE="1" STATE="1" TYPTYPE="3" TYPE="ZAPLINK_ACID_DATA">
    <TEXTS>
     <ITEM LANG="E" TEXT="Data for Function group"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TO_VARIANT" EXPOSURE="1" STATE="1" TYPTYPE="3" TYPE="ZAPLINK_FUNC_DATA">
    <TEXTS>
     <ITEM LANG="E" TEXT="Commun Data for Class &amp; Interface"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TS_FMD_ACID" EXPOSURE="1" STATE="1" TYPTYPE="1" TYPE="ZAPLINK_ACID_DATA=&gt;TS_FM_DATA"/>
  </TYPES>
 </RAW>
</ZL_OBJECT>
